<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TriX Gaming Platform</title>
    <script src="./ethers-6.7.1.umd.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header">
        <h1>ğŸ® TriX Gaming Platform</h1>
        <p>Blockchain Gaming with Smart Contracts</p>
      </div>

      <!-- Wallet Section -->
      <div class="wallet-section">
        <div class="wallet-info">
          <div class="wallet-connection">
            <button id="connectBtn" class="btn btn-primary">
              <span id="connectBtnText">Connect Wallet</span>
            </button>
            <div class="connection-status">
              <div class="status-dot" id="statusDot"></div>
              <span id="connectionStatus">Not Connected</span>
            </div>
          </div>

          <div class="balance-info">
            <div class="balance-item">
              <span class="balance-label">ETH</span>
              <span class="balance-value" id="ethBalance">0.0000</span>
            </div>
            <div class="balance-item">
              <span class="balance-label">GT</span>
              <span class="balance-value" id="gtBalance">0.00</span>
            </div>
            <div class="balance-item">
              <span class="balance-label">USDT</span>
              <span class="balance-value" id="usdtBalance">0.00</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Grid -->
      <div class="main-grid">
        <!-- Buy GT with USDT -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ’°</span>
            <span>Buy GT with USDT</span>
          </div>

          <div class="form-group">
            <label class="form-label" for="usdtAmount">USDT Amount</label>
            <input
              class="form-input"
              type="number"
              id="usdtAmount"
              placeholder="Enter USDT amount"
              step="0.01"
              min="0"
            />
          </div>

          <div class="form-group">
            <label class="form-label" for="gtReceive">GT to Receive</label>
            <input
              class="form-input"
              type="text"
              id="gtReceive"
              placeholder="GT amount"
              readonly
            />
          </div>

          <button id="buyBtn" class="btn btn-primary" disabled>
            <span>Purchase GameTokens</span>
          </button>

          <button id="faucetBtn" class="btn btn-secondary" disabled>
            <span>ğŸš° Get Test USDT</span>
          </button>

          <div class="info-text">
            ğŸ’¡ 1:1 conversion rate â€¢ No fees â€¢ Instant processing
          </div>
        </div>

        <!-- Realtime Matchmaking (Demo) -->
        <div class="card">
          <div class="section-header">
            <span class="icon">âš¡</span>
            <span>Realtime Matchmaking (Demo)</span>
          </div>

          <div class="form-group">
            <label class="form-label" for="mmStake">Stake Amount (GT)</label>
            <input
              class="form-input"
              type="number"
              id="mmStake"
              placeholder="e.g. 10"
              step="0.01"
              min="0"
            />
          </div>

          <button id="findOpponentBtn" class="btn btn-primary" disabled>
            <span>ğŸ” Find Opponent</span>
          </button>

          <div id="mmStatus" class="info-text" style="margin-top: 8px">
            Connect wallet to use matchmaking
          </div>

          <div id="mmStakeConfirm" class="hidden" style="margin-top: 12px">
            <button id="confirmStakeBtn" class="btn btn-warning">
              <span>âœ… Approve & Stake</span>
            </button>
            <div class="info-text">
              Approve and stake the GT amount to enter escrow.
            </div>
          </div>

          <div id="mmCancel" class="hidden" style="margin-top: 12px">
            <button id="cancelMatchmakingBtn" class="btn btn-danger">
              <span>âŒ Cancel & Refund</span>
            </button>
            <div class="info-text">
              Cancel matchmaking and get your stake back.
            </div>
          </div>

          <div id="mmGame" class="hidden" style="margin-top: 16px">
            <div id="mmTurn" class="info-text" style="margin-bottom: 8px"></div>
            <div
              id="mmBoard"
              style="
                display: grid;
                grid-template-columns: repeat(3, 64px);
                gap: 6px;
              "
            ></div>
          </div>

          <!-- Debug Info -->
          <div
            class="debug-info"
            style="
              margin-top: 15px;
              padding: 10px;
              background: #f8f9fa;
              border-radius: 5px;
              font-size: 0.85rem;
            "
          >
            <strong>ğŸ” Debug Info:</strong>
            <div>Socket ID: <span id="debugSocketId">-</span></div>
            <div>Match ID: <span id="debugMatchId">-</span></div>
            <div>
              Blockchain Match ID: <span id="debugBlockchainMatchId">-</span>
            </div>
            <div>Player Role: <span id="debugPlayerRole">-</span></div>
            <div>Game Status: <span id="debugGameStatus">-</span></div>
          </div>

          <!-- Etherscan Links -->
          <div
            id="etherscanLinks"
            class="hidden"
            style="
              margin-top: 15px;
              padding: 10px;
              background: #e3f2fd;
              border-radius: 5px;
              font-size: 0.85rem;
            "
          >
            <strong>ğŸ”— Etherscan Links:</strong>
            <div id="matchCreationLink" style="margin-top: 5px"></div>
            <div id="player1StakingLink" style="margin-top: 5px"></div>
            <div id="player2StakingLink" style="margin-top: 5px"></div>
            <div id="resultSubmissionLink" style="margin-top: 5px"></div>
            <div
              id="matchDetailsLink"
              style="
                margin-top: 10px;
                padding-top: 10px;
                border-top: 1px solid #ccc;
              "
            ></div>
          </div>

          <!-- Debug Actions -->
          <div
            id="debugActions"
            class="hidden"
            style="
              margin-top: 15px;
              padding: 10px;
              background: #fff3cd;
              border-radius: 5px;
              font-size: 0.85rem;
            "
          >
            <strong>ğŸ› Debug Actions:</strong>
            <div style="margin-top: 10px">
              <button
                id="debugGameStartBtn"
                class="btn btn-warning btn-sm"
                style="margin-right: 10px"
              >
                ğŸ® Force Game Start
              </button>
              <button id="debugEmitStakedBtn" class="btn btn-info btn-sm">
                ğŸ”” Re-emit playerStaked
              </button>
            </div>
          </div>
        </div>

        <!-- Create/Stake Match -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ¯</span>
            <span>Create New Match</span>
          </div>

          <div class="form-group">
            <label class="form-label" for="matchId"
              >Match ID (Auto-generated)</label
            >
            <input
              class="form-input"
              type="text"
              id="matchId"
              placeholder="Will be auto-generated..."
              readonly
            />
          </div>

          <div class="form-group">
            <label class="form-label" for="player1"
              >Player 1 Wallet Address</label
            >
            <input
              class="form-input"
              type="text"
              id="player1"
              placeholder="0x... (first player's wallet address)"
            />
          </div>

          <div class="form-group">
            <label class="form-label" for="player2"
              >Player 2 Wallet Address</label
            >
            <input
              class="form-input"
              type="text"
              id="player2"
              placeholder="0x... (second player's wallet address)"
            />
          </div>

          <div class="form-group">
            <label class="form-label" for="stakeAmount"
              >Stake Amount (GT)</label
            >
            <input
              class="form-input"
              type="number"
              id="stakeAmount"
              placeholder="Amount each player stakes"
              step="0.01"
              min="0"
            />
            <small
              style="
                color: var(--text-secondary);
                font-size: 0.75rem;
                margin-top: 0.25rem;
                display: block;
              "
            >
              Both players must stake exactly this amount
            </small>
          </div>

          <button id="createMatchBtn" class="btn btn-success" disabled>
            <span>ğŸ® Create Match</span>
          </button>

          <div class="info-text">
            ğŸ“ Anyone can create matches for any two players. The assigned
            players will see the match in their "My Matches" section and can
            stake.
          </div>
        </div>
      </div>

      <!-- Bottom Grid -->
      <div class="bottom-grid">
        <!-- My Matches -->
        <div class="card">
          <div class="section-header">
            <span class="icon">âš”ï¸</span>
            <span>My Matches</span>
          </div>

          <button
            id="refreshMatchesBtn"
            class="btn btn-secondary"
            style="margin-bottom: 1rem; width: 100%"
          >
            <span>ğŸ”„ Refresh Matches</span>
          </button>

          <div class="events-container" id="myMatchesList">
            <div class="event-item">
              <div class="event-time">No matches found</div>
              <div class="event-content">
                Create a match or wait to be assigned to one
              </div>
            </div>
          </div>

          <div class="form-group" style="margin-top: var(--space-6)">
            <label class="form-label" for="manualMatchId"
              >Or Join by Match ID</label
            >
            <input
              class="form-input"
              type="text"
              id="manualMatchId"
              placeholder="Enter full match ID (0x...)"
            />
          </div>

          <button id="stakeInMatchBtn" class="btn btn-warning" disabled>
            <span>âš¡ Stake in Match</span>
          </button>

          <div class="info-text">
            ğŸ† Winner takes all â€¢ Exactly 2x stake â€¢ Zero fees
          </div>
          <div
            class="info-text"
            style="margin-top: 10px; font-size: 0.9em; color: #888"
          >
            ğŸ’¡ <strong>Need GT tokens?</strong> Buy them with USDT in the "Buy
            GT with USDT" section above!
          </div>
        </div>

        <!-- Result Declaration -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ†</span>
            <span>Declare Match Result</span>
          </div>

          <div class="form-group">
            <label class="form-label" for="resultMatchId">Match ID</label>
            <input
              class="form-input"
              type="text"
              id="resultMatchId"
              placeholder="Enter full match ID (0x...)"
              style="width: 100%; margin-bottom: 10px"
            />
            <button
              type="button"
              id="refreshMatchBtn"
              class="btn btn-secondary"
              style="width: 100%; padding: 10px"
            >
              ğŸ”„ Refresh Match Data
            </button>
          </div>

          <div class="form-group">
            <label class="form-label">Select Winner</label>
            <div
              style="
                display: flex;
                flex-direction: column;
                gap: var(--space-3);
                margin-top: var(--space-2);
              "
            >
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: var(--space-2);
                  cursor: pointer;
                "
              >
                <input
                  type="radio"
                  name="winner"
                  id="player1Winner"
                  value=""
                  style="margin: 0"
                />
                <span id="player1Label"
                  >Player 1: Connect wallet to load match</span
                >
              </label>
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: var(--space-2);
                  cursor: pointer;
                "
              >
                <input
                  type="radio"
                  name="winner"
                  id="player2Winner"
                  value=""
                  style="margin: 0"
                />
                <span id="player2Label"
                  >Player 2: Connect wallet to load match</span
                >
              </label>
            </div>
          </div>

          <button id="declareResultBtn" class="btn btn-success" disabled>
            <span>ğŸ† Announce Winner</span>
          </button>

          <div class="info-text">
            ğŸ† Winner receives the complete escrow amount (2x stake). This
            action is irreversible.
          </div>
        </div>

        <!-- Activity Feed -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ“‹</span>
            <span>Activity Feed</span>
          </div>
          <div class="events-container" id="eventsList">
            <div class="event-item">
              <div class="event-time">Waiting for activity...</div>
              <div class="event-content">Connect wallet to start</div>
            </div>
          </div>
        </div>

        <!-- Leaderboard -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ†</span>
            <span>Leaderboard</span>
            <button
              type="button"
              onclick="loadLeaderboard()"
              class="btn btn-secondary"
              style="margin-left: auto; font-size: 0.8rem; padding: 5px 10px"
            >
              ğŸ”„ Refresh
            </button>
          </div>
          <div
            style="
              font-size: 0.7rem;
              color: #888;
              text-align: center;
              margin-bottom: 10px;
            "
          >
            âš¡ Auto-refresh every 10 seconds
          </div>
          <div id="leaderboardList">
            <div class="event-item">
              <div class="event-time">Loading leaderboard...</div>
              <div class="event-content">Click refresh to load</div>
            </div>
          </div>
        </div>

        <!-- Account Overview -->
        <div class="card">
          <div class="section-header">
            <span class="icon">ğŸ®</span>
            <span>Account Overview</span>
          </div>

          <div class="balance-details">
            <h3>Balance Details</h3>
            <div id="balanceDetails">
              <div class="balance-grid">
                <div class="balance-row">
                  <span class="balance-row-label">Status</span>
                  <span class="balance-row-value">Connect wallet</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Status Container -->
      <div id="statusContainer"></div>
    </div>

    <script>
      // Global variables
      let provider;
      let signer;
      let userAddress;
      let contracts = {};
      let CONFIG = {
        rpcUrl: "http://127.0.0.1:8545",
        chainId: 1337, // Localhost chain ID
        contracts: {
          GAME_TOKEN: "0x...", // Will be loaded from backend
          TOKEN_STORE: "0x...", // Will be loaded from backend
          PLAY_GAME: "0x...", // Will be loaded from backend
          MOCK_USDT: "0x...", // Will be loaded from backend
        },
        apiBaseUrl: "http://localhost:3000", // Local API base URL
      };
      let isConnected = false;
      let assignedMatches = new Map(); // Track matches assigned to current user

      // Contract ABIs
      const ABIS = {
        ERC20: [
          "function balanceOf(address) view returns (uint256)",
          "function approve(address,uint256) returns (bool)",
          "function allowance(address,address) view returns (uint256)",
        ],
        TokenStore: [
          "function buy(uint256) external",
          "function getGTAmount(uint256) view returns (uint256)",
        ],
        PlayGame: [
          "function createMatch(bytes32,address,address,uint256) external",
          "function stake(bytes32) external",
          "function commitResult(bytes32,address) external",
          "function refund(bytes32) external",
          "function getMatch(bytes32) view returns (tuple(bytes32,address,address,uint256,uint8,uint256,bool,bool))",
          "function canRefund(bytes32) view returns (bool)",
          "function getStats() view returns (uint256,uint256,uint256)",
        ],
        MockUSDT: [
          "function faucet() external",
          "function faucetCooldown(address) view returns (uint256)",
        ],
      };

      // DOM elements
      const connectBtn = document.getElementById("connectBtn");
      const connectBtnText = document.getElementById("connectBtnText");
      const statusDot = document.getElementById("statusDot");
      const connectionStatus = document.getElementById("connectionStatus");
      const ethBalance = document.getElementById("ethBalance");
      const gtBalance = document.getElementById("gtBalance");
      const usdtBalance = document.getElementById("usdtBalance");
      const usdtAmount = document.getElementById("usdtAmount");
      const gtReceive = document.getElementById("gtReceive");
      const buyBtn = document.getElementById("buyBtn");
      const faucetBtn = document.getElementById("faucetBtn");
      const matchId = document.getElementById("matchId");
      const player1 = document.getElementById("player1");
      const player2 = document.getElementById("player2");
      const stakeAmount = document.getElementById("stakeAmount");
      const createMatchBtn = document.getElementById("createMatchBtn");
      const myMatchesList = document.getElementById("myMatchesList");
      const refreshMatchesBtn = document.getElementById("refreshMatchesBtn");
      const manualMatchId = document.getElementById("manualMatchId");
      const stakeInMatchBtn = document.getElementById("stakeInMatchBtn");
      const findOpponentBtn = document.getElementById("findOpponentBtn");
      const mmStake = document.getElementById("mmStake");
      const mmStatus = document.getElementById("mmStatus");
      const mmStakeConfirm = document.getElementById("mmStakeConfirm");
      const confirmStakeBtn = document.getElementById("confirmStakeBtn");
      const mmCancel = document.getElementById("mmCancel");
      const mmGame = document.getElementById("mmGame");
      const mmBoard = document.getElementById("mmBoard");
      const mmTurn = document.getElementById("mmTurn");
      const resultMatchId = document.getElementById("resultMatchId");
      const player1Winner = document.getElementById("player1Winner");
      const player2Winner = document.getElementById("player2Winner");
      const player1Label = document.getElementById("player1Label");
      const player2Label = document.getElementById("player2Label");
      const declareResultBtn = document.getElementById("declareResultBtn");
      const eventsList = document.getElementById("eventsList");
      const balanceDetails = document.getElementById("balanceDetails");
      const statusContainer = document.getElementById("statusContainer");

      // Initialize
      async function init() {
        try {
          console.log("ğŸš€ Initializing application...");

          // Check if we're in local development or production
          const isLocal =
            window.location.hostname === "localhost" ||
            window.location.hostname === "127.0.0.1";

          if (isLocal) {
            // Local development - get config from backend
            console.log("ğŸ” Checking local backend status...");
            const response = await fetch("http://localhost:3000/health");
            const healthData = await response.json();

            CONFIG = {
              rpcUrl: "http://127.0.0.1:8545",
              chainId: 1337,
              contracts: healthData.contracts,
              apiBaseUrl: "http://localhost:3000",
            };
          } else {
            // Production on Vercel
            console.log("ğŸŒ Production mode - checking Vercel API...");
            try {
              const response = await fetch(
                "https://trix-mpe3.onrender.com/health"
              );
              const healthData = await response.json();

              CONFIG = {
                rpcUrl:
                  "https://eth-sepolia.g.alchemy.com/v2/1NFhV9cMA4vShirJHIwX2",
                chainId: 11155111, // Sepolia
                contracts: healthData.contracts,
                apiBaseUrl: "https://trix-mpe3.onrender.com",
              };
            } catch (error) {
              console.warn(
                "âš ï¸ Could not load production config, using fallback"
              );
              CONFIG = {
                rpcUrl:
                  "https://eth-sepolia.g.alchemy.com/v2/1NFhV9cMA4vShirJHIwX2",
                chainId: 11155111, // Sepolia
                contracts: {
                  GAME_TOKEN: "0x7740aF6224458cd62CEDC93f3E47735d3628Aa23",
                  TOKEN_STORE: "0x574c85CBB55533f75894613D1869AC0EBC515156",
                  PLAY_GAME: "0xa3eE2EF1A305105445006E97d970443A063E76DD",
                  MOCK_USDT: "0x9620fEfD83D6038f80148A686E3258C2E15dEE96",
                },
                apiBaseUrl: "https://trix-mpe3.onrender.com",
              };
            }
          }
          console.log("âœ… Configuration loaded:", CONFIG.contracts);

          // Check network status (only for localhost)
          if (
            window.location.hostname === "localhost" ||
            window.location.hostname === "127.0.0.1"
          ) {
            console.log("ğŸ” Checking Hardhat node status...");
            try {
              const hardhatResponse = await fetch("http://localhost:8545", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  method: "eth_blockNumber",
                  params: [],
                  id: 1,
                }),
              });
              const hardhatData = await hardhatResponse.json();
              console.log("âœ… Hardhat node status:", hardhatData);
            } catch (hardhatError) {
              console.error("âŒ Hardhat node not responding:", hardhatError);
              showStatus("âŒ Hardhat node not running", "error");
            }
          } else {
            console.log("ğŸŒ Production mode - skipping Hardhat check");
          }

          updateConnectionStatus(false);

          // Check if wallet is already connected
          if (window.ethereum && window.ethereum.selectedAddress) {
            console.log("ğŸ”— Wallet already connected, reconnecting...");
            connectBtn.click();
          }

          // Function to check wallet connection status
          function checkWalletConnection() {
            if (window.isWalletConnected && window.userAddress) {
              console.log("âœ… Wallet connection verified:", window.userAddress);
              if (findOpponentBtn) {
                findOpponentBtn.disabled = false;
                console.log("âœ… Find Opponent button enabled");
              }
              return true;
            } else {
              console.log("âŒ Wallet not connected");
              if (findOpponentBtn) {
                findOpponentBtn.disabled = true;
                console.log("âŒ Find Opponent button disabled");
              }
              return false;
            }
          }

          // Check wallet connection status every 2 seconds
          setInterval(checkWalletConnection, 2000);
        } catch (error) {
          console.error("âŒ Failed to load configuration:", error);
          showStatus("âŒ Failed to connect to backend", "error");
        }
      }

      // Validate network connection
      async function validateNetwork() {
        try {
          console.log("ğŸŒ Validating network connection...");

          if (!window.ethereum) {
            console.error("âŒ MetaMask not detected");
            return false;
          }

          console.log("ğŸ” Checking current network...");
          const chainId = await window.ethereum.request({
            method: "eth_chainId",
          });
          console.log("ğŸ”— Current chainId:", chainId);

          // Check if we're in production or localhost
          const isLocalhost =
            window.location.hostname === "localhost" ||
            window.location.hostname === "127.0.0.1";
          const expectedChainId = isLocalhost ? "0x539" : "0xaa36a7"; // 1337 for localhost, 11155111 for Sepolia
          const expectedNetworkName = isLocalhost
            ? "Localhost 8545"
            : "Sepolia Testnet";

          if (chainId !== expectedChainId) {
            console.error(
              `âŒ Wrong network! Expected ${expectedChainId} (${expectedNetworkName}), got:`,
              chainId
            );

            // Try to automatically switch to the correct network
            try {
              console.log(
                `ğŸ”„ Attempting to switch to ${expectedNetworkName}...`
              );
              await window.ethereum.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: expectedChainId }],
              });
              console.log(`âœ… Successfully switched to ${expectedNetworkName}`);
              return true;
            } catch (switchError) {
              console.error("âŒ Failed to switch network:", switchError);

              // If the network doesn't exist, try to add it
              if (switchError.code === 4902) {
                try {
                  console.log(`â• Adding ${expectedNetworkName}...`);
                  const networkParams = isLocalhost
                    ? {
                        chainId: "0x539",
                        chainName: "Localhost 8545",
                        nativeCurrency: {
                          name: "Ether",
                          symbol: "ETH",
                          decimals: 18,
                        },
                        rpcUrls: ["http://127.0.0.1:8545"],
                        blockExplorerUrls: [],
                      }
                    : {
                        chainId: "0xaa36a7",
                        chainName: "Sepolia Testnet",
                        nativeCurrency: {
                          name: "Sepolia Ether",
                          symbol: "ETH",
                          decimals: 18,
                        },
                        rpcUrls: [
                          "https://eth-sepolia.g.alchemy.com/v2/1NFhV9cMA4vShirJHIwX2",
                        ],
                        blockExplorerUrls: ["https://sepolia.etherscan.io"],
                      };

                  await window.ethereum.request({
                    method: "wallet_addEthereumChain",
                    params: [networkParams],
                  });
                  console.log(`âœ… Successfully added ${expectedNetworkName}`);
                  return true;
                } catch (addError) {
                  console.error("âŒ Failed to add network:", addError);
                }
              }

              showStatus(`âŒ Please switch to ${expectedNetworkName}`, "error");
              return false;
            }
          }

          console.log("âœ… Network validation successful");
          return true;
        } catch (error) {
          console.error("âŒ Network validation failed:", error);
          return false;
        }
      }

      // Try to bypass circuit breaker by using a different provider approach
      async function createDirectProvider() {
        try {
          console.log(
            "ğŸ”§ Creating direct provider to bypass circuit breaker..."
          );

          // Create a direct provider that bypasses MetaMask's circuit breaker
          const directProvider = new ethers.JsonRpcProvider(
            "http://127.0.0.1:8545"
          );

          // Test the direct connection
          const blockNumber = await directProvider.getBlockNumber();
          console.log(
            "âœ… Direct provider connected, block number:",
            blockNumber
          );

          return directProvider;
        } catch (error) {
          console.error("âŒ Direct provider failed:", error);
          return null;
        }
      }

      // Bypass circuit breaker by trying multiple approaches
      async function bypassCircuitBreaker() {
        console.log("ğŸ”„ Attempting to bypass circuit breaker...");

        // Method 1: Try direct provider
        console.log("ğŸ”§ Method 1: Trying direct provider...");
        const directProvider = await createDirectProvider();
        if (directProvider) {
          console.log("âœ… Direct provider successful!");
          return directProvider;
        }

        // Method 2: Try different RPC URL
        console.log("ğŸ”§ Method 2: Trying different RPC URL...");
        try {
          const altProvider = new ethers.JsonRpcProvider(
            "http://localhost:8545"
          );
          const blockNumber = await altProvider.getBlockNumber();
          console.log("âœ… Alternative RPC URL successful!");
          return altProvider;
        } catch (error) {
          console.error("âŒ Alternative RPC URL failed:", error);
        }

        // Method 3: Try with different network settings
        console.log("ğŸ”§ Method 3: Trying to switch network...");
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x539" }],
          });
          console.log("âœ… Network switch successful!");
          return provider;
        } catch (error) {
          console.error("âŒ Network switch failed:", error);
        }

        console.log("âŒ All bypass methods failed");
        return null;
      }

      // Update connection status
      function updateConnectionStatus(connected) {
        isConnected = connected;

        if (connected) {
          connectBtnText.textContent = "Connected";
          connectBtn.classList.remove("btn-primary");
          connectBtn.classList.add("btn-success");
          connectBtn.disabled = true;
          statusDot.classList.add("connected");
          connectionStatus.textContent = `Connected: ${userAddress?.slice(
            0,
            6
          )}...${userAddress?.slice(-4)}`;
        } else {
          connectBtnText.textContent = "Connect Wallet";
          connectBtn.classList.remove("btn-success");
          connectBtn.classList.add("btn-primary");
          connectBtn.disabled = false;
          statusDot.classList.remove("connected");
          connectionStatus.textContent = "Not Connected";
        }
      }

      // Connect wallet
      connectBtn.onclick = async () => {
        try {
          console.log("ğŸ”— Starting wallet connection...");

          if (!window.ethereum) {
            console.error("âŒ MetaMask not detected");
            showStatus("âŒ MetaMask not detected", "error");
            return;
          }

          console.log("âœ… MetaMask detected, requesting accounts...");
          connectBtn.innerHTML =
            '<div class="spinner"></div><span>Connecting...</span>';

          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });
          console.log("ğŸ“‹ Accounts received:", accounts);

          // Validate network
          console.log("ğŸŒ Validating network...");
          const networkValid = await validateNetwork();
          if (!networkValid) {
            console.error("âŒ Network validation failed");
            connectBtn.innerHTML = "<span>Connect Wallet</span>";
            return;
          }

          console.log("ğŸ”§ Creating provider...");
          provider = new ethers.BrowserProvider(window.ethereum);
          console.log("ğŸ”§ Getting signer...");
          signer = await provider.getSigner();
          userAddress = accounts[0];
          console.log("ğŸ‘¤ User address:", userAddress);

          console.log("ğŸŒ Getting network info...");
          const network = await provider.getNetwork();
          console.log("ğŸŒ Connected to network:", network);

          console.log("ğŸ“‹ Contract addresses from config:", CONFIG.contracts);

          console.log("ğŸ”§ Initializing GameToken contract...");
          contracts.gameToken = new ethers.Contract(
            CONFIG.contracts.GAME_TOKEN,
            ABIS.ERC20,
            signer
          );
          console.log("ğŸ”§ Initializing TokenStore contract...");
          contracts.tokenStore = new ethers.Contract(
            CONFIG.contracts.TOKEN_STORE,
            ABIS.TokenStore,
            signer
          );
          console.log("ğŸ”§ Initializing PlayGame contract...");
          contracts.playGame = new ethers.Contract(
            CONFIG.contracts.PLAY_GAME,
            ABIS.PlayGame,
            signer
          );
          console.log("ğŸ”§ Initializing MockUSDT contract...");
          contracts.mockUsdt = new ethers.Contract(
            CONFIG.contracts.MOCK_USDT,
            ABIS.ERC20.concat(ABIS.MockUSDT),
            signer
          );

          console.log("âœ… All contracts initialized");
          updateConnectionStatus(true);

          // Set global wallet state
          window.isWalletConnected = true;
          window.userAddress = userAddress;

          console.log("ğŸ’° Updating balances...");
          await updateBalances();

          // Start auto-refresh for balances
          startBalanceAutoRefresh();

          // Start debug info updates
          setInterval(updateDebugInfo, 2000);
          setInterval(updateEtherscanLinks, 2000);

          // Setup debug actions (will be configured after socket is initialized)
          const debugActions = document.getElementById("debugActions");
          const debugGameStartBtn =
            document.getElementById("debugGameStartBtn");
          const debugEmitStakedBtn =
            document.getElementById("debugEmitStakedBtn");

          // Store references for later setup
          window.debugActions = debugActions;
          window.debugGameStartBtn = debugGameStartBtn;
          window.debugEmitStakedBtn = debugEmitStakedBtn;

          // Enable buttons
          buyBtn.disabled = false;
          createMatchBtn.disabled = false;
          stakeInMatchBtn.disabled = false;
          declareResultBtn.disabled = false;
          faucetBtn.disabled = false;

          // Enable matchmaking button only if wallet is connected
          if (findOpponentBtn) {
            findOpponentBtn.disabled = false;
            console.log("âœ… Find Opponent button enabled");
          }

          console.log("ğŸ® Loading assigned matches...");
          await loadAssignedMatches();

          console.log("ğŸ† Loading leaderboard...");
          await loadLeaderboard();

          // Start auto-refresh for leaderboard
          startLeaderboardAutoRefresh();

          console.log("âœ… Wallet connection complete!");
          showStatus("âœ… Wallet connected successfully!", "success");
          addEvent("ğŸ‰ Wallet connected and ready");
          setupMatchmaking();
        } catch (error) {
          console.error("âŒ Wallet connection failed:", error);
          showStatus("âŒ Connection failed: " + error.message, "error");
          connectBtn.innerHTML = "<span>Connect Wallet</span>";
        }
      };

      // ======== Realtime Matchmaking (Demo) ========
      let socket;
      // Will be set based on environment
      const mmState = {
        socketMatchId: null,
        blockchainMatchId: null,
        player1: null,
        player2: null,
        stake: null,
        mySymbol: null,
        isMyTurn: false,
        // Transaction hashes for Etherscan links
        creationTxHash: null,
        player1StakingTxHash: null,
        player2StakingTxHash: null,
        resultTxHash: null,
      };

      function setupMatchmaking() {
        try {
          if (!window.io) {
            console.warn("Socket.IO not loaded");
            return;
          }

          // Set matchmaking URL based on environment
          const MATCHMAKING_URL =
            window.location.hostname === "localhost"
              ? "http://localhost:3002"
              : "https://trix-mpe3.onrender.com";

          socket = io(MATCHMAKING_URL, { transports: ["websocket"] });
          mmStatus.textContent =
            "Connected to matchmaking. Enter stake and click Find Opponent.";

          // Setup debug actions now that socket is available
          if (
            window.debugActions &&
            window.debugGameStartBtn &&
            window.debugEmitStakedBtn
          ) {
            // Show debug actions when match is found
            socket.on("matchFound", () => {
              window.debugActions.classList.remove("hidden");
            });

            // Force game start button
            window.debugGameStartBtn.onclick = () => {
              console.log("ğŸ› Force game start clicked");
              if (mmState.socketMatchId) {
                socket.emit("forceGameStart", {
                  matchId: mmState.socketMatchId,
                });
              }
            };

            // Re-emit playerStaked button
            window.debugEmitStakedBtn.onclick = () => {
              console.log("ğŸ› Re-emit playerStaked clicked");
              if (mmState.socketMatchId && mmState.blockchainMatchId) {
                socket.emit("playerStaked", {
                  matchId: mmState.socketMatchId,
                  address: userAddress,
                  blockchainMatchId: mmState.blockchainMatchId,
                });
              }
            };

            console.log("âœ… Debug actions configured");
          }

          // Matchmaking status updates
          socket.on("matchmakingStatus", (data) => {
            mmStatus.textContent = data.message || data.status;

            if (data.status === "waiting") {
              mmCancel.classList.remove("hidden");
              findOpponentBtn.disabled = true;
            } else if (data.status === "matched") {
              mmCancel.classList.add("hidden");
            } else if (data.status === "cancelled") {
              mmCancel.classList.add("hidden");
              findOpponentBtn.disabled = false;
            }
          });

          // Match found
          socket.on("matchFound", (matchData) => {
            mmState.socketMatchId = matchData.matchId;
            mmState.player1 = matchData.player1;
            mmState.player2 = matchData.player2;
            mmState.stake = matchData.stake;
            mmStatus.textContent = `Match found! ${short(
              matchData.player1
            )} vs ${short(matchData.player2)} â€¢ Stake ${matchData.stake} GT`;

            // Update debug info
            updateDebugInfo();

            // Only player1 creates the match to avoid race conditions
            const isPlayer1 =
              userAddress.toLowerCase() === matchData.player1.toLowerCase();
            if (isPlayer1) {
              console.log("ğŸ® I'm Player 1, creating match on-chain...");
              createMatchOnChain(matchData);
            } else {
              console.log("ğŸ¯ I'm Player 2, waiting for match creation...");
              mmStatus.textContent = `Match found! Waiting for match creation...`;
            }
          });

          // Match created on blockchain - Player 2 can now stake
          socket.on("matchCreatedOnChain", async (data) => {
            if (data.matchId !== mmState.socketMatchId) return;

            const isPlayer2 =
              userAddress.toLowerCase() === mmState.player2.toLowerCase();
            if (isPlayer2) {
              console.log(
                "âœ… Match created on-chain, now staking as Player 2..."
              );
              mmState.blockchainMatchId = data.blockchainMatchId;

              // Update debug info
              updateDebugInfo();

              try {
                mmStatus.textContent = `Match created! Now staking ${mmState.stake} GT...`;

                // Approve and stake GT tokens
                const amountWei = ethers.parseUnits(String(mmState.stake), 18);

                // 1) Approve spending
                console.log("ğŸ” Approving GT tokens...");
                const approveTx = await contracts.gameToken.approve(
                  CONFIG.contracts.PLAY_GAME,
                  amountWei
                );
                await approveTx.wait();
                console.log("âœ… GT tokens approved");

                // 2) Stake in the match
                console.log("ğŸ¯ Staking in match...");
                const stakeTx = await contracts.playGame.stake(
                  data.blockchainMatchId
                );
                await stakeTx.wait();
                mmState.player2StakingTxHash = stakeTx.hash; // Store Player 2 staking transaction hash
                console.log("âœ… Staking successful");
                console.log(
                  "ğŸ”— Player 2 staking transaction hash:",
                  stakeTx.hash
                );

                // Display Etherscan links for Player 2 staking
                const etherscanBase =
                  window.location.hostname === "localhost"
                    ? "https://sepolia.etherscan.io"
                    : "https://sepolia.etherscan.io";

                mmStatus.innerHTML = `
                  <div>âœ… Staked ${
                    mmState.stake
                  } GT! Waiting for game start...</div>
                  <div style="margin-top: 10px; font-size: 0.9rem;">
                    <strong>Transaction Links:</strong><br>
                    <a href="${etherscanBase}/tx/${
                  approveTx.hash
                }" target="_blank" style="color: #007bff;">
                      ğŸ” GT Approval: ${short(approveTx.hash)}
                    </a><br>
                    <a href="${etherscanBase}/tx/${
                  stakeTx.hash
                }" target="_blank" style="color: #007bff;">
                      âš¡ Player 2 Staking: ${short(stakeTx.hash)}
                    </a>
                  </div>
                `;

                // Notify that we've staked
                console.log("ğŸ”” Emitting playerStaked event:", {
                  matchId: mmState.socketMatchId,
                  address: userAddress,
                  blockchainMatchId: data.blockchainMatchId,
                });

                socket.emit("playerStaked", {
                  matchId: mmState.socketMatchId,
                  address: userAddress, // âœ… Changed from 'player' to 'address' to match backend
                  blockchainMatchId: data.blockchainMatchId,
                });

                console.log("âœ… playerStaked event emitted successfully");
              } catch (e) {
                console.error("âŒ Player 2 staking failed:", e);
                mmStatus.textContent = `Failed to stake: ${e.message}`;
              }
            }
          });

          // Game start
          socket.on("gameStart", ({ matchId, symbol, isFirst }) => {
            console.log("ğŸ® Game start event received:", {
              matchId,
              symbol,
              isFirst,
            });
            console.log(
              "ğŸ® Current mmState.socketMatchId:",
              mmState.socketMatchId
            );

            if (matchId !== mmState.socketMatchId) {
              console.log("âŒ Match ID mismatch, ignoring game start");
              return;
            }

            console.log("âœ… Game starting! Building board...");
            mmState.mySymbol = symbol;
            mmState.isMyTurn = !!isFirst;
            mmGame.classList.remove("hidden");
            buildBoard();
            updateTurnText();

            // Update status to show game has started
            mmStatus.innerHTML = `
              <div>ğŸ® Game started! You are playing as <strong>${symbol}</strong></div>
              <div style="margin-top: 5px; font-size: 0.9rem;">
                ${
                  mmState.isMyTurn
                    ? "ğŸŸ¢ It's your turn!"
                    : "â³ Waiting for opponent..."
                }
              </div>
            `;

            // Update debug info
            updateDebugInfo();

            console.log("ğŸ® Game board built and ready!");
          });

          // Opponent move
          socket.on("moveMade", ({ row, col, symbol, nextPlayer }) => {
            console.log(
              `ğŸ¯ Move received: ${symbol} at (${row}, ${col}), nextPlayer: ${nextPlayer}`
            );

            const idx = row * 3 + col;
            const cell = mmBoard.children[idx];
            if (cell && !cell.textContent) {
              cell.textContent = symbol;
              console.log(
                `âœ… Move displayed on board: ${symbol} at index ${idx}`
              );
            } else {
              console.log(
                `âš ï¸ Could not display move: cell ${idx} already has content or doesn't exist`
              );
            }

            // Check if game is over
            if (nextPlayer === "GAME_OVER") {
              console.log(`ğŸ Game over detected from moveMade event`);
              mmState.isMyTurn = false;
              updateTurnText();
            } else {
              mmState.isMyTurn = nextPlayer === mmState.mySymbol;
              updateTurnText();
            }
          });

          // Game end
          socket.on(
            "gameEnded",
            async ({ result, winnerAddress, finalBoard }) => {
              console.log(`ğŸ Game ended event received:`, {
                result,
                winnerAddress,
                finalBoard,
              });

              if (finalBoard) {
                finalBoard.forEach((v, i) => {
                  if (v && mmBoard.children[i])
                    mmBoard.children[i].textContent = v;
                });
              }

              if (winnerAddress) {
                console.log(`ğŸ† Winner detected: ${winnerAddress} (${result})`);
                mmStatus.textContent = `Game over. Winner: ${short(
                  winnerAddress
                )}. Submitting result on-chain...`;
                // Only winner submits result to avoid duplicate submissions
                if (
                  winnerAddress.toLowerCase() === userAddress.toLowerCase() &&
                  mmState.blockchainMatchId
                ) {
                  try {
                    console.log(`ğŸ† Submitting result for match:`, {
                      blockchainMatchId: mmState.blockchainMatchId,
                      winner: winnerAddress,
                    });

                    const resp = await fetch(
                      `${CONFIG.apiBaseUrl}/match/result`,
                      {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                          matchId: mmState.blockchainMatchId,
                          winner: winnerAddress,
                        }),
                      }
                    );
                    const data = await resp.json();
                    if (!resp.ok)
                      throw new Error(data.error || "Commit failed");
                    // Display Etherscan links for all transactions
                    const etherscanBase =
                      window.location.hostname === "localhost"
                        ? "https://sepolia.etherscan.io"
                        : "https://sepolia.etherscan.io";

                    mmStatus.innerHTML = `
                      <div>âœ… Result submitted successfully!</div>
                      <div style="margin-top: 10px; font-size: 0.9rem;">
                        <strong>Transaction Links:</strong><br>
                        <a href="${etherscanBase}/tx/${
                      data.txHash
                    }" target="_blank" style="color: #007bff;">
                          ğŸ¯ Result Submission: ${short(data.txHash)}
                        </a>
                      </div>
                    `;

                    // Store result transaction hash
                    mmState.resultTxHash = data.txHash;

                    // Add to events list
                    addEvent(
                      `ğŸ† Game won by ${short(
                        winnerAddress
                      )} - Result submitted on-chain`
                    );
                  } catch (e) {
                    console.error("Result submission error:", e);

                    // Try to get more details from the response
                    let errorMessage = e.message;
                    if (e.response) {
                      try {
                        const errorData = await e.response.json();
                        errorMessage = errorData.error || errorMessage;
                      } catch (parseError) {
                        console.error(
                          "Could not parse error response:",
                          parseError
                        );
                      }
                    }

                    mmStatus.innerHTML = `
                      <div style="color: #dc3545;">âŒ Failed to submit result: ${errorMessage}</div>
                      <div style="margin-top: 10px; font-size: 0.9rem;">
                        <strong>Debug Info:</strong><br>
                        Blockchain Match ID: ${mmState.blockchainMatchId}<br>
                        Winner: ${winnerAddress}<br>
                        <button onclick="debugMatch('${mmState.blockchainMatchId}')" style="margin-top: 5px; padding: 5px 10px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">
                          ğŸ” Debug Match on Backend
                        </button>
                      </div>
                    `;
                  }
                }
              } else {
                mmStatus.textContent = "Game ended in a draw.";
              }
            }
          );
        } catch (err) {
          console.error("Matchmaking setup failed", err);
        }
      }

      function short(addr) {
        if (!addr) return "";
        return `${addr.slice(0, 6)}â€¦${addr.slice(-4)}`;
      }

      // Debug function to check match status on backend
      async function debugMatch(blockchainMatchId) {
        try {
          console.log(`ğŸ” Debugging match: ${blockchainMatchId}`);

          // Extract the WebSocket matchId from mmState
          const webSocketMatchId = mmState.socketMatchId;
          if (!webSocketMatchId) {
            console.error("No WebSocket matchId found in mmState");
            return;
          }

          const resp = await fetch(
            `${CONFIG.apiBaseUrl}/debug/match/${webSocketMatchId}`
          );
          const data = await resp.json();

          console.log("ğŸ” Backend debug response:", data);

          if (data.success) {
            alert(
              `âœ… Match found on-chain!\n\nWebSocket ID: ${
                data.webSocketMatchId
              }\nBlockchain ID: ${
                data.blockchainMatchId
              }\nOn-chain data: ${JSON.stringify(data.onChainData, null, 2)}`
            );
          } else {
            alert(
              `âŒ Match not found on-chain!\n\nWebSocket ID: ${data.webSocketMatchId}\nBlockchain ID: ${data.blockchainMatchId}\nError: ${data.error}`
            );
          }
        } catch (error) {
          console.error("Debug match error:", error);
          alert(`Debug failed: ${error.message}`);
        }
      }

      function buildBoard() {
        mmBoard.innerHTML = "";
        for (let i = 0; i < 9; i++) {
          const btn = document.createElement("button");
          btn.className = "btn btn-secondary";
          btn.style.width = "64px";
          btn.style.height = "64px";
          btn.style.fontSize = "20px";
          btn.style.padding = "0";
          btn.onclick = () => doMove(i);
          mmBoard.appendChild(btn);
        }
      }

      function updateTurnText() {
        mmTurn.textContent = mmState.isMyTurn ? "Your turn" : "Opponent's turn";
      }

      function updateDebugInfo() {
        const debugSocketId = document.getElementById("debugSocketId");
        const debugMatchId = document.getElementById("debugMatchId");
        const debugBlockchainMatchId = document.getElementById(
          "debugBlockchainMatchId"
        );
        const debugPlayerRole = document.getElementById("debugPlayerRole");
        const debugGameStatus = document.getElementById("debugGameStatus");

        if (debugSocketId) debugSocketId.textContent = socket?.id || "-";
        if (debugMatchId)
          debugMatchId.textContent = mmState.socketMatchId || "-";
        if (debugBlockchainMatchId)
          debugBlockchainMatchId.textContent = mmState.blockchainMatchId || "-";

        let playerRole = "-";
        if (mmState.player1 && mmState.player2) {
          if (userAddress?.toLowerCase() === mmState.player1.toLowerCase()) {
            playerRole = "Player 1 (X)";
          } else if (
            userAddress?.toLowerCase() === mmState.player2.toLowerCase()
          ) {
            playerRole = "Player 2 (O)";
          }
        }
        if (debugPlayerRole) debugPlayerRole.textContent = playerRole;

        let gameStatus = "-";
        if (mmState.socketMatchId) {
          if (mmState.blockchainMatchId) {
            gameStatus = "Match Created";
            if (mmState.mySymbol) {
              gameStatus += ` - Playing as ${mmState.mySymbol}`;
            }
          } else {
            gameStatus = "Match Found";
          }
        }
        if (debugGameStatus) debugGameStatus.textContent = gameStatus;
      }

      function updateEtherscanLinks() {
        const etherscanLinks = document.getElementById("etherscanLinks");
        const matchCreationLink = document.getElementById("matchCreationLink");
        const player1StakingLink =
          document.getElementById("player1StakingLink");
        const player2StakingLink =
          document.getElementById("player2StakingLink");
        const resultSubmissionLink = document.getElementById(
          "resultSubmissionLink"
        );

        if (!etherscanLinks) return;

        const etherscanBase =
          window.location.hostname === "localhost"
            ? "https://sepolia.etherscan.io"
            : "https://sepolia.etherscan.io";

        let hasLinks = false;

        // Match Creation Link
        if (mmState.creationTxHash) {
          matchCreationLink.innerHTML = `
            <a href="${etherscanBase}/tx/${
            mmState.creationTxHash
          }" target="_blank" style="color: #007bff;">
              ğŸ® Match Creation: ${short(mmState.creationTxHash)}
            </a>
          `;
          hasLinks = true;
        }

        // Player 1 Staking Link
        if (mmState.player1StakingTxHash) {
          player1StakingLink.innerHTML = `
            <a href="${etherscanBase}/tx/${
            mmState.player1StakingTxHash
          }" target="_blank" style="color: #007bff;">
              âš¡ Player 1 Staking: ${short(mmState.player1StakingTxHash)}
            </a>
          `;
          hasLinks = true;
        }

        // Player 2 Staking Link
        if (mmState.player2StakingTxHash) {
          player2StakingLink.innerHTML = `
            <a href="${etherscanBase}/tx/${
            mmState.player2StakingTxHash
          }" target="_blank" style="color: #007bff;">
              âš¡ Player 2 Staking: ${short(mmState.player2StakingTxHash)}
            </a>
          `;
          hasLinks = true;
        }

        // Result Submission Link
        if (mmState.resultTxHash) {
          resultSubmissionLink.innerHTML = `
            <a href="${etherscanBase}/tx/${
            mmState.resultTxHash
          }" target="_blank" style="color: #007bff;">
              ğŸ¯ Result Submission: ${short(mmState.resultTxHash)}
            </a>
          `;
          hasLinks = true;
        }

        // Match Details Link (contract interaction)
        if (mmState.blockchainMatchId) {
          const matchDetailsLink = document.getElementById("matchDetailsLink");
          if (matchDetailsLink) {
            matchDetailsLink.innerHTML = `
              <a href="${etherscanBase}/address/${
              CONFIG.contracts.PLAY_GAME
            }#readContract" target="_blank" style="color: #007bff;">
                ğŸ“‹ View Match Details on Contract: ${short(
                  CONFIG.contracts.PLAY_GAME
                )}
              </a>
            `;
            hasLinks = true;
          }
        }

        // Show/hide the section based on whether we have links
        if (hasLinks) {
          etherscanLinks.classList.remove("hidden");
        } else {
          etherscanLinks.classList.add("hidden");
        }
      }

      async function doMove(index) {
        if (!mmState.isMyTurn) return;
        const row = Math.floor(index / 3);
        const col = index % 3;
        socket.emit("makeMove", {
          matchId: mmState.socketMatchId,
          row,
          col,
          symbol: mmState.mySymbol,
        });
      }

      async function createMatchOnChain(matchData) {
        try {
          console.log("ğŸ® Creating match on-chain:", matchData);

          // Create match on-chain via backend (uses operator wallet)
          const resp = await fetch(`${CONFIG.apiBaseUrl}/match/start`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              p1: matchData.player1,
              p2: matchData.player2,
              stake: matchData.stake,
              matchId: matchData.matchId,
            }),
          });
          const data = await resp.json();
          if (!resp.ok) throw new Error(data.error || "Failed to create match");

          console.log("ğŸ” Backend response data:", data);
          console.log("ğŸ” Transaction hash from backend:", data.txHash);

          // Store the ACTUAL blockchain matchId from the backend response
          mmState.blockchainMatchId = data.blockchainMatchId;
          mmState.creationTxHash = data.txHash; // Store creation transaction hash
          console.log("âœ… Match created on-chain:", data.blockchainMatchId);
          console.log("ğŸ”— Creation transaction hash:", data.txHash);

          // Now both players need to stake in this match
          mmStatus.textContent = `Match created! Now staking ${matchData.stake} GT...`;

          // Approve and stake GT tokens
          const amountWei = ethers.parseUnits(String(matchData.stake), 18);

          // 1) Approve spending
          console.log("ğŸ” Approving GT tokens...");
          const approveTx = await contracts.gameToken.approve(
            CONFIG.contracts.PLAY_GAME,
            amountWei
          );
          await approveTx.wait();
          console.log("âœ… GT tokens approved");

          // 2) Stake in the actual match
          console.log("ğŸ¯ Staking in match...");
          // Use the blockchain matchId from the backend response
          const stakeTx = await contracts.playGame.stake(
            data.blockchainMatchId
          );
          await stakeTx.wait();
          mmState.player1StakingTxHash = stakeTx.hash; // Store Player 1 staking transaction hash
          console.log("âœ… Staking successful");
          console.log("ğŸ”— Player 1 staking transaction hash:", stakeTx.hash);

          // Display Etherscan links for match creation and staking
          const etherscanBase =
            window.location.hostname === "localhost"
              ? "https://sepolia.etherscan.io"
              : "https://sepolia.etherscan.io";

          mmStatus.innerHTML = `
            <div>âœ… Staked ${matchData.stake} GT! Waiting for opponent...</div>
            <div style="margin-top: 10px; font-size: 0.9rem;">
              <strong>Transaction Links:</strong><br>
              <a href="${etherscanBase}/tx/${
            data.txHash
          }" target="_blank" style="color: #007bff;">
                ğŸ® Match Creation: ${short(data.txHash)}
              </a><br>
              <a href="${etherscanBase}/tx/${
            stakeTx.hash
          }" target="_blank" style="color: #007bff;">
                âš¡ Player 1 Staking: ${short(stakeTx.hash)}
              </a>
            </div>
          `;

          // Validate the blockchain matchId before using it
          try {
            if (!ethers.isHexString(data.blockchainMatchId, 32)) {
              throw new Error("Invalid blockchain matchId format");
            }
            console.log(
              "ğŸ”” Blockchain matchId validated:",
              data.blockchainMatchId
            );
          } catch (error) {
            console.error("âŒ Invalid blockchain matchId:", error);
            mmStatus.textContent =
              "Failed to validate match ID. Please try again.";
            return;
          }

          // CRITICAL: Player 1 must also emit playerStaked event after staking
          console.log("ğŸ”” Player 1 emitting playerStaked event:", {
            matchId: matchData.matchId,
            address: userAddress,
            blockchainMatchId: data.blockchainMatchId,
          });

          socket.emit("playerStaked", {
            matchId: matchData.matchId,
            address: userAddress,
            blockchainMatchId: data.blockchainMatchId,
          });

          console.log("âœ… Player 1 playerStaked event emitted");

          // Notify matchmaking server that match is created and Player 1 has staked
          socket.emit("matchCreated", {
            matchId: matchData.matchId,
            player1: matchData.player1,
            player2: matchData.player2,
            stake: matchData.stake,
            blockchainMatchId: data.blockchainMatchId, // âœ… Use the blockchain matchId from backend
            playerStaked: userAddress,
          });

          console.log("ğŸ”” Emitting notifyPlayer2 with data:", {
            matchId: matchData.matchId,
            blockchainMatchId: data.blockchainMatchId,
            createdBy: userAddress,
            txHash: data.txHash, // Include transaction hash from backend
          });

          // Ensure we have a valid transaction hash
          if (!data.txHash) {
            console.warn(
              "âš ï¸ No transaction hash received from backend, using fallback"
            );
          }

          socket.emit("notifyPlayer2", {
            matchId: matchData.matchId,
            blockchainMatchId: data.blockchainMatchId, // Now this is the correct bytes32 hash
            createdBy: userAddress,
            txHash: data.txHash || "pending", // Include transaction hash for Etherscan links
          });

          console.log("âœ… All events emitted for Player 1");
        } catch (e) {
          console.error("âŒ Match creation/staking failed:", e);
          mmStatus.textContent = `Failed to create/stake in match: ${e.message}`;
        }
      }

      findOpponentBtn.onclick = async () => {
        if (!socket) return;
        const stake = parseFloat(mmStake.value);
        if (!stake || stake <= 0) {
          mmStatus.textContent = "Enter a valid stake amount";
          return;
        }

        try {
          // For now, skip pre-staking and go directly to matchmaking
          // The actual staking will happen when both players are matched
          console.log("ğŸ” Starting matchmaking without pre-staking...");

          // Check if user has enough GT tokens first
          const amountWei = ethers.parseUnits(String(stake), 18);
          const gtBalance = await contracts.gameToken.balanceOf(userAddress);

          if (gtBalance < amountWei) {
            mmStatus.textContent = `âŒ Insufficient GT balance. You have ${ethers.formatEther(
              gtBalance
            )} GT, need ${stake} GT.`;
            return;
          }

          // Notify matchmaking server to find a match
          socket.emit("findMatch", {
            address: userAddress,
            stake: parseInt(stake),
          });

          mmState.stake = stake;
          mmStatus.textContent = "Searching for opponent...";
          findOpponentBtn.disabled = true;
        } catch (e) {
          console.error(e);
          mmStatus.textContent = `Failed to start matchmaking: ${e.message}`;
        }
      };

      // Cancel matchmaking button
      document.getElementById("cancelMatchmakingBtn").onclick = async () => {
        if (!socket) return;

        try {
          socket.emit("cancelMatchmaking", { address: userAddress });
          mmStatus.textContent = "Matchmaking cancelled.";
          findOpponentBtn.disabled = false;
          mmCancel.classList.add("hidden");
        } catch (e) {
          console.error(e);
          mmStatus.textContent = `Failed to cancel: ${e.message}`;
        }
      };

      // Update balances
      async function updateBalances() {
        try {
          const ethBal = await provider.getBalance(userAddress);
          ethBalance.textContent = parseFloat(
            ethers.formatEther(ethBal)
          ).toFixed(4);

          if (contracts.gameToken) {
            const gtBal = await contracts.gameToken.balanceOf(userAddress);
            gtBalance.textContent = parseFloat(
              ethers.formatEther(gtBal)
            ).toFixed(2);
          }

          if (contracts.mockUsdt) {
            const usdtBal = await contracts.mockUsdt.balanceOf(userAddress);
            usdtBalance.textContent = parseFloat(
              ethers.formatUnits(usdtBal, 6)
            ).toFixed(2);
          }

          // Update detailed view
          balanceDetails.innerHTML = `
                                  <div class="balance-grid">
            <div class="balance-row">
              <span class="balance-row-label">ğŸ’ ETH</span>
              <span class="balance-row-value">${ethBalance.textContent}</span>
            </div>
            <div class="balance-row">
              <span class="balance-row-label">ğŸ® Game Tokens</span>
              <span class="balance-row-value">${gtBalance.textContent} GT</span>
            </div>
            <div class="balance-row">
              <span class="balance-row-label">ğŸ’° USDT</span>
              <span class="balance-row-value">${usdtBalance.textContent} USDT</span>
            </div>
            <div class="balance-row">
              <span class="balance-row-label">ğŸ”— Network</span>
              <span class="balance-row-value">Localhost</span>
            </div>
          </div>
          <div class="address-display">
            <strong>Address:</strong><br>${userAddress}
          </div>
          <div style="margin-top: 10px; text-align: center;">
            <button
              type="button"
              onclick="updateBalances()"
              class="btn btn-secondary"
              style="font-size: 0.8rem; padding: 5px 10px;"
            >
              ğŸ”„ Refresh Balances
            </button>
            <div style="font-size: 0.7rem; color: #888; margin-top: 5px;">
              âš¡ Auto-refresh every 5 seconds
            </div>
          </div>
                      `;
        } catch (error) {
          console.error("Balance update failed:", error);
        }
      }

      // Auto-refresh balances periodically
      let balanceRefreshInterval;
      function startBalanceAutoRefresh() {
        if (balanceRefreshInterval) {
          clearInterval(balanceRefreshInterval);
        }
        // Refresh balances every 5 seconds when connected
        balanceRefreshInterval = setInterval(async () => {
          if (isConnected && userAddress) {
            await updateBalances();
          }
        }, 5000);
      }

      function stopBalanceAutoRefresh() {
        if (balanceRefreshInterval) {
          clearInterval(balanceRefreshInterval);
          balanceRefreshInterval = null;
        }
      }

      // Calculate GT amount
      usdtAmount.oninput = async () => {
        if (!contracts.tokenStore || !usdtAmount.value) {
          gtReceive.value = "";
          return;
        }

        try {
          const usdtWei = ethers.parseUnits(usdtAmount.value, 6);
          const gtAmount = await contracts.tokenStore.getGTAmount(usdtWei);
          gtReceive.value = ethers.formatEther(gtAmount);
        } catch (error) {
          gtReceive.value = "Error";
        }
      };

      // Faucet
      faucetBtn.onclick = async () => {
        try {
          console.log("ğŸš° Starting faucet process...");
          console.log("ğŸ‘¤ User address:", userAddress);
          console.log("ğŸ’° MockUSDT contract:", CONFIG.contracts.MOCK_USDT);

          showStatus("ğŸš° Getting test USDT...", "warning");
          faucetBtn.innerHTML =
            '<div class="spinner"></div><span>Getting...</span>';

          console.log("â›½ Estimating gas for faucet...");
          const gasEstimate = await contracts.mockUsdt.faucet.estimateGas();
          const gasLimit = (gasEstimate * 120n) / 100n;
          console.log("â›½ Faucet gas estimate:", gasEstimate.toString());
          console.log("â›½ Faucet gas limit:", gasLimit.toString());

          console.log("ğŸ“ Sending faucet transaction...");
          const tx = await contracts.mockUsdt.faucet({ gasLimit });
          console.log("ğŸ“ Faucet transaction sent:", tx.hash);
          console.log("â³ Waiting for faucet confirmation...");
          await tx.wait();
          console.log("âœ… Faucet transaction confirmed");

          await updateBalances();
          faucetBtn.innerHTML = "<span>ğŸš° Get Test USDT</span>";
          showStatus("ğŸ‰ Received 1000 test USDT!", "success");
          addEvent("ğŸ’° Received 1000 USDT from faucet");
        } catch (error) {
          console.error("âŒ Faucet failed:", error);
          console.error("âŒ Faucet error details:", {
            message: error.message,
            code: error.code,
            data: error.data,
            transaction: error.transaction,
          });

          if (error.message.includes("circuit breaker")) {
            console.error(
              "ğŸ”§ Circuit breaker detected in faucet - attempting bypass..."
            );
            showStatus(
              "ğŸ”„ Circuit breaker detected, attempting bypass...",
              "warning"
            );

            // Try to bypass the circuit breaker
            const bypassProvider = await bypassCircuitBreaker();
            if (bypassProvider) {
              console.log("âœ… Bypass successful, retrying faucet...");
              showStatus("âœ… Bypass successful, retrying...", "success");

              try {
                // Create new contract with bypass provider
                const bypassSigner = bypassProvider.getSigner(userAddress);
                const bypassMockUsdt = new ethers.Contract(
                  CONFIG.contracts.MOCK_USDT,
                  ABIS.ERC20.concat(ABIS.MockUSDT),
                  bypassSigner
                );

                console.log("ğŸš° Retrying faucet with bypass provider...");
                const bypassTx = await bypassMockUsdt.faucet({ gasLimit });
                await bypassTx.wait();
                console.log("âœ… Faucet successful with bypass!");

                await updateBalances();
                faucetBtn.innerHTML = "<span>ğŸš° Get Test USDT</span>";
                showStatus("ğŸ‰ Received 1000 test USDT!", "success");
                addEvent("ğŸ’° Received 1000 USDT from faucet");
                return;
              } catch (bypassError) {
                console.error("âŒ Bypass retry failed:", bypassError);
              }
            }
          }

          faucetBtn.innerHTML = "<span>ğŸš° Get Test USDT</span>";

          if (error.message.includes("circuit breaker")) {
            showStatus(
              "âŒ MetaMask blocked faucet. Try the bypass button below.",
              "error"
            );

            // Add a bypass button for faucet
            setTimeout(() => {
              const faucetBypassBtn = document.createElement("button");
              faucetBypassBtn.className = "btn btn-primary";
              faucetBypassBtn.style.marginTop = "10px";
              faucetBypassBtn.innerHTML = "ğŸ”„ Try Faucet Bypass";
              faucetBypassBtn.onclick = async () => {
                console.log("ğŸ”„ Manual faucet bypass attempt...");
                showStatus("ğŸ”„ Attempting manual faucet bypass...", "warning");

                const bypassProvider = await bypassCircuitBreaker();
                if (bypassProvider) {
                  try {
                    const bypassSigner = bypassProvider.getSigner(userAddress);
                    const bypassMockUsdt = new ethers.Contract(
                      CONFIG.contracts.MOCK_USDT,
                      ABIS.ERC20.concat(ABIS.MockUSDT),
                      bypassSigner
                    );

                    const gasEstimate =
                      await bypassMockUsdt.faucet.estimateGas();
                    const gasLimit = (gasEstimate * 120n) / 100n;

                    const bypassTx = await bypassMockUsdt.faucet({ gasLimit });
                    await bypassTx.wait();

                    await updateBalances();
                    showStatus("ğŸ‰ Faucet successful with bypass!", "success");
                    addEvent("ğŸ’° Received 1000 USDT from faucet (bypass)");
                  } catch (bypassError) {
                    console.error(
                      "âŒ Manual faucet bypass failed:",
                      bypassError
                    );
                    showStatus(
                      "âŒ Manual bypass failed: " + bypassError.message,
                      "error"
                    );
                  }
                } else {
                  showStatus(
                    "âŒ Bypass failed. Please reset network settings.",
                    "error"
                  );
                }
              };
              const statusMessage = document.querySelector(".status-message");
              if (statusMessage) {
                statusMessage.appendChild(faucetBypassBtn);
              }
            }, 1000);
          } else {
            showStatus("âŒ Faucet failed: " + error.message, "error");
          }
        }
      };

      // Buy GT
      buyBtn.onclick = async () => {
        try {
          const amount = parseFloat(usdtAmount.value);
          if (!amount || amount <= 0) {
            showStatus("âš ï¸ Enter valid USDT amount", "warning");
            return;
          }

          showStatus("â³ Purchasing GT tokens...", "warning");
          buyBtn.innerHTML =
            '<div class="spinner"></div><span>Purchasing...</span>';

          const usdtWei = ethers.parseUnits(amount.toString(), 6);

          // Approve USDT
          const approveGas = await contracts.mockUsdt.approve.estimateGas(
            CONFIG.contracts.TOKEN_STORE,
            usdtWei
          );
          const approveTx = await contracts.mockUsdt.approve(
            CONFIG.contracts.TOKEN_STORE,
            usdtWei,
            { gasLimit: (approveGas * 120n) / 100n }
          );
          await approveTx.wait();

          // Purchase tokens
          const purchaseGas = await contracts.tokenStore.buy.estimateGas(
            usdtWei
          );
          const purchaseTx = await contracts.tokenStore.buy(usdtWei, {
            gasLimit: (purchaseGas * 120n) / 100n,
          });
          await purchaseTx.wait();

          await updateBalances();
          usdtAmount.value = "";
          gtReceive.value = "";
          buyBtn.innerHTML = "<span>Purchase GameTokens</span>";

          showStatus("ğŸ‰ GT tokens purchased!", "success");
          addEvent(`ğŸ›’ Purchased ${amount} GT with ${amount} USDT`);
        } catch (error) {
          console.error(error);
          buyBtn.innerHTML = "<span>Purchase GameTokens</span>";
          showStatus("âŒ Purchase failed: " + error.message, "error");
        }
      };

      // Create Match
      createMatchBtn.onclick = async () => {
        try {
          const player1Value = player1.value.trim();
          const player2Value = player2.value.trim();
          const stakeValue = parseFloat(stakeAmount.value);

          if (!player1Value || !player2Value || !stakeValue) {
            showStatus(
              "âš ï¸ Enter both player addresses and stake amount",
              "warning"
            );
            return;
          }

          if (!ethers.isAddress(player1Value)) {
            showStatus("âš ï¸ Invalid Player 1 address", "warning");
            return;
          }

          if (!ethers.isAddress(player2Value)) {
            showStatus("âš ï¸ Invalid Player 2 address", "warning");
            return;
          }

          if (player1Value.toLowerCase() === player2Value.toLowerCase()) {
            showStatus("âš ï¸ Player addresses cannot be the same", "warning");
            return;
          }

          // Debug logging
          console.log("Creating match with:", {
            p1: player1Value,
            p2: player2Value,
            stake: stakeValue,
            createdBy: userAddress,
          });

          showStatus("â³ Creating match...", "warning");
          createMatchBtn.innerHTML =
            '<div class="spinner"></div><span>Creating...</span>';

          const requestBody = {
            p1: player1Value,
            p2: player2Value,
            stake: stakeValue,
          };

          console.log("Sending request:", requestBody);

          const response = await fetch(
            `${CONFIG.apiBaseUrl}/match/start?t=${Date.now()}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(requestBody),
            }
          );

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.error || "Match creation failed");
          }

          // Clear form and update UI
          matchId.value = result.matchIdString || ""; // Show generated ID for reference
          player1.value = "";
          player2.value = "";
          stakeAmount.value = "";
          createMatchBtn.innerHTML = "<span>ğŸ® Create Match</span>";

          showStatus("ğŸ‰ Match created successfully!", "success");
          addEvent(
            `ğŸ¯ Created match "${result.matchIdString}" - ${player1Value.slice(
              0,
              6
            )}...${player1Value.slice(-4)} vs ${player2Value.slice(
              0,
              6
            )}...${player2Value.slice(-4)} (${stakeValue} GT each)`
          );

          // Refresh assigned matches to show the new match
          setTimeout(async () => {
            await loadAssignedMatches();
          }, 1000); // Small delay to ensure blockchain state is updated
        } catch (error) {
          console.error(error);
          createMatchBtn.innerHTML = "<span>ğŸ® Create Match</span>";
          showStatus("âŒ Match creation failed: " + error.message, "error");
        }
      };

      // Refresh matches button
      refreshMatchesBtn.onclick = async () => {
        if (!userAddress) {
          showStatus("âš ï¸ Connect wallet first", "warning");
          return;
        }

        refreshMatchesBtn.innerHTML =
          '<div class="spinner"></div><span>Refreshing...</span>';

        try {
          await loadAssignedMatches();
          showStatus("âœ… Matches refreshed", "success");
        } catch (error) {
          console.error("Refresh failed:", error);
          showStatus("âŒ Refresh failed: " + error.message, "error");
        }

        refreshMatchesBtn.innerHTML = "<span>ğŸ”„ Refresh Matches</span>";
      };

      // Load assigned matches for current user
      async function loadAssignedMatches() {
        if (!userAddress || !contracts.playGame) return;

        try {
          console.log("Loading assigned matches for:", userAddress);
          console.log("Using contract address:", CONFIG.contracts.PLAY_GAME);
          console.log("Provider network:", await provider.getNetwork());

          // Debug MetaMask connection
          try {
            const rpcUrl = await window.ethereum.request({
              method: "eth_chainId",
            });
            console.log("MetaMask chainId:", rpcUrl);

            // Check what network MetaMask thinks it's on
            const networkVersion = await window.ethereum.request({
              method: "net_version",
            });
            console.log("MetaMask network version:", networkVersion);
          } catch (err) {
            console.log("MetaMask debug failed:", err);
          }

          // Clear existing matches
          assignedMatches.clear();

          // Get MatchCreated events - try direct approach
          try {
            const eventTopic = ethers.id(
              "MatchCreated(bytes32,address,address,uint256)"
            );
            // Query all events from contract (workaround for MetaMask filtering issue)
            const allLogsFilter = {
              address: CONFIG.contracts.PLAY_GAME,
              fromBlock: 0,
              toBlock: "latest",
            };

            // Use broader query and filter in JS (workaround for MetaMask/ethers.js filtering bug)
            const allLogsFromContract = await provider.getLogs(allLogsFilter);
            const logs = allLogsFromContract.filter(
              (log) => log.topics[0] === eventTopic
            );
            console.log("Found MatchCreated events:", logs.length);

            for (const log of logs) {
              // Decode manually since event has indexed parameters
              const matchId = log.topics[1]; // First indexed parameter
              const p1 = "0x" + log.topics[2].slice(-40); // Second indexed parameter
              const p2 = "0x" + log.topics[3].slice(-40); // Third indexed parameter
              const stake = ethers.getBigInt(log.data); // Non-indexed parameter

              // Check if current user is either player
              if (
                p1.toLowerCase() === userAddress.toLowerCase() ||
                p2.toLowerCase() === userAddress.toLowerCase()
              ) {
                console.log("Found assigned match:", matchId.toString());

                // Get actual match status from blockchain
                try {
                  const matchData = await contracts.playGame.getMatch(matchId);
                  console.log("Match data from blockchain:", matchData);

                  assignedMatches.set(matchId.toString(), {
                    matchId: matchId.toString(),
                    matchIdString: `match_${Date.now()}`, // Generate readable ID
                    p1,
                    p2,
                    stake: ethers.formatEther(stake),
                    status: matchData[4], // MatchStatus enum
                    p1Staked: matchData[6], // p1Staked boolean
                    p2Staked: matchData[7], // p2Staked boolean
                    startTime: matchData[5], // startTime
                  });
                } catch (matchError) {
                  console.error("Error fetching match data:", matchError);
                  // Fallback to event data only
                  assignedMatches.set(matchId.toString(), {
                    matchId: matchId.toString(),
                    matchIdString: `match_${Date.now()}`, // Generate readable ID
                    p1,
                    p2,
                    stake: ethers.formatEther(stake),
                    status: 0, // Assume CREATED status from event
                    p1Staked: false, // Will be updated when staking events are processed
                    p2Staked: false, // Will be updated when staking events are processed
                  });
                }
              }
            }
          } catch (eventError) {
            console.error("Error fetching events:", eventError);
            // Fall back to empty list if event fetching fails
          }

          // Update the UI
          refreshMatchesList();
        } catch (error) {
          console.error("Error loading assigned matches:", error);
        }
      }

      // Refresh the matches list UI
      function refreshMatchesList() {
        if (assignedMatches.size === 0) {
          myMatchesList.innerHTML = `
                        <div class="event-item">
                          <div class="event-time">No matches found</div>
                          <div class="event-content">Create a match or wait to be assigned to one</div>
                                    </div>
                                `;
          return;
        }

        myMatchesList.innerHTML = "";

        for (const [matchId, matchData] of assignedMatches) {
          addMatchToList(
            matchData.matchIdString,
            matchData.matchId,
            matchData.p1,
            matchData.p2,
            matchData.stake,
            matchData.p1Staked,
            matchData.p2Staked
          );
        }
      }

      // Add match to "My Matches" list
      function addMatchToList(
        matchIdString,
        matchIdBytes32,
        p1,
        p2,
        stake,
        p1Staked,
        p2Staked
      ) {
        const isMyTurn =
          (userAddress.toLowerCase() === p1.toLowerCase() && !p1Staked) ||
          (userAddress.toLowerCase() === p2.toLowerCase() && !p2Staked);

        const matchItem = document.createElement("div");
        matchItem.className = "event-item";
        matchItem.style.cursor = isMyTurn ? "pointer" : "default";

        const statusText =
          p1Staked && p2Staked
            ? "ğŸ‰ Both Staked - Ready!"
            : p1Staked
            ? "â³ Player 1 Staked - Waiting for Player 2"
            : p2Staked
            ? "â³ Player 2 Staked - Waiting for Player 1"
            : "â³ Waiting for Both Players to Stake";

        const role =
          userAddress.toLowerCase() === p1.toLowerCase()
            ? "Player 1"
            : "Player 2";
        const myStakeStatus =
          (userAddress.toLowerCase() === p1.toLowerCase() && p1Staked) ||
          (userAddress.toLowerCase() === p2.toLowerCase() && p2Staked)
            ? "âœ… You Staked"
            : "âŒ You Need to Stake";

        // Show opponent's staking status
        const opponentStaked =
          (userAddress.toLowerCase() === p1.toLowerCase() && p2Staked) ||
          (userAddress.toLowerCase() === p2.toLowerCase() && p1Staked);
        const opponentStatus = opponentStaked
          ? "âœ… Opponent Staked"
          : "â³ Opponent Not Staked";

        matchItem.innerHTML = `
                      <div class="event-time">${matchIdString} â€¢ ${stake} GT â€¢ ${statusText}</div>
                      <div class="event-content">
                        <div style="margin-bottom: 0.5rem;">
                          <strong>${role}</strong> â€¢ ${myStakeStatus}
                        </div>
                        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                          <div>ğŸ‘¤ Opponent: ${
                            role === "Player 1"
                              ? p2.slice(0, 6) + "..." + p2.slice(-4)
                              : p1.slice(0, 6) + "..." + p1.slice(-4)
                          }</div>
                          <div>${opponentStatus}</div>
                        </div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); word-break: break-all;">
                          Match ID: ${matchIdBytes32}
                        </div>
                      </div>
                    `;

        if (isMyTurn) {
          matchItem.onclick = () => stakeInMatch(matchIdBytes32, stake);
          matchItem.style.borderLeftColor = "var(--border-neon)";
        }

        // Remove "No matches found" if it exists
        if (
          myMatchesList.children[0]?.textContent?.includes("No matches found")
        ) {
          myMatchesList.innerHTML = "";
        }

        myMatchesList.appendChild(matchItem);
      }

      // Stake in a specific match
      async function stakeInMatch(matchIdBytes32, stakeAmount) {
        try {
          console.log("ğŸ¯ Starting staking process...");
          console.log("ğŸ¯ Match ID:", matchIdBytes32);
          console.log("ğŸ¯ Stake Amount:", stakeAmount);
          console.log("ğŸ‘¤ User address:", userAddress);
          console.log("ğŸ® PlayGame contract:", CONFIG.contracts.PLAY_GAME);
          console.log("ğŸ® GameToken contract:", CONFIG.contracts.GAME_TOKEN);

          showStatus("â³ Checking GT balance...", "warning");

          // Check GT balance first
          console.log("ğŸ’° Checking GT balance...");
          let gtBalance;
          try {
            gtBalance = await contracts.gameToken.balanceOf(userAddress);
            console.log(
              "âœ… GT balance check successful:",
              ethers.formatEther(gtBalance)
            );
          } catch (error) {
            console.error("âŒ GT balance check failed:", error);
            console.error("âŒ Error details:", {
              message: error.message,
              code: error.code,
              data: error.data,
            });
            showStatus(
              "âŒ Cannot check GT balance. Please buy GT tokens first.",
              "error"
            );
            return;
          }

          const requiredAmount = ethers.parseEther(stakeAmount.toString());
          console.log(
            "ğŸ’° Required amount:",
            ethers.formatEther(requiredAmount)
          );

          if (gtBalance < requiredAmount) {
            console.log("âŒ Insufficient GT balance");
            showStatus(
              `âŒ Insufficient GT balance. You have ${ethers.formatEther(
                gtBalance
              )} GT, need ${stakeAmount} GT. Please buy GT tokens first.`,
              "error"
            );
            return;
          }

          console.log("âœ… GT balance sufficient");
          showStatus("â³ Approving GT tokens...", "warning");

          // Check current allowance
          console.log("ğŸ” Checking current allowance...");
          let currentAllowance;
          try {
            currentAllowance = await contracts.gameToken.allowance(
              userAddress,
              CONFIG.contracts.PLAY_GAME
            );
            console.log(
              "âœ… Allowance check successful:",
              ethers.formatEther(currentAllowance)
            );
          } catch (error) {
            console.warn("âš ï¸ Allowance check failed, assuming 0:", error);
            console.warn("âš ï¸ Error details:", {
              message: error.message,
              code: error.code,
              data: error.data,
            });
            currentAllowance = ethers.getBigInt(0);
          }

          if (currentAllowance < requiredAmount) {
            console.log("ğŸ” Approval needed");
            console.log(
              "ğŸ” Current allowance:",
              ethers.formatEther(currentAllowance)
            );
            console.log(
              "ğŸ” Required amount:",
              ethers.formatEther(requiredAmount)
            );

            try {
              console.log("ğŸ” Estimating gas for approval...");
              const approveGasEstimate =
                await contracts.gameToken.approve.estimateGas(
                  CONFIG.contracts.PLAY_GAME,
                  requiredAmount
                );
              console.log(
                "â›½ Approval gas estimate:",
                approveGasEstimate.toString()
              );

              console.log("ğŸ” Sending approval transaction...");
              const approveTx = await contracts.gameToken.approve(
                CONFIG.contracts.PLAY_GAME,
                requiredAmount
              );
              console.log("ğŸ“ Approval transaction sent:", approveTx.hash);
              console.log("â³ Waiting for approval confirmation...");
              await approveTx.wait();
              console.log("âœ… Approval transaction confirmed");
              showStatus("âœ… GT tokens approved", "success");
            } catch (approveError) {
              console.error("âŒ Approval failed:", approveError);
              console.error("âŒ Approval error details:", {
                message: approveError.message,
                code: approveError.code,
                data: approveError.data,
                transaction: approveError.transaction,
              });
              throw approveError;
            }
          } else {
            console.log("âœ… Sufficient allowance already exists");
          }

          console.log("ğŸ¯ Starting stake transaction...");
          showStatus("â³ Staking in match...", "warning");

          try {
            console.log("ğŸ¯ Estimating gas for staking...");
            const stakeGasEstimate = await contracts.playGame.stake.estimateGas(
              matchIdBytes32
            );
            console.log("â›½ Stake gas estimate:", stakeGasEstimate.toString());

            console.log("ğŸ¯ Sending stake transaction...");
            const stakeTx = await contracts.playGame.stake(matchIdBytes32);
            console.log("ğŸ“ Stake transaction sent:", stakeTx.hash);
            console.log("â³ Waiting for stake confirmation...");
            await stakeTx.wait();
            console.log("âœ… Stake transaction confirmed");

            await updateBalances();
            await loadAssignedMatches(); // Refresh matches to show updated status

            showStatus("ğŸ‰ Successfully staked in match!", "success");
            addEvent(`âš¡ Staked ${stakeAmount} GT in match`);
          } catch (stakeError) {
            console.error("âŒ Staking failed:", stakeError);
            console.error("âŒ Staking error details:", {
              message: stakeError.message,
              code: stakeError.code,
              data: stakeError.data,
              transaction: stakeError.transaction,
            });
            throw stakeError;
          }
        } catch (error) {
          console.error("âŒ Staking error:", error);
          console.error("âŒ Full error object:", error);

          if (error.message.includes("insufficient funds")) {
            showStatus("âŒ Insufficient ETH for gas fees", "error");
          } else if (error.message.includes("rejected")) {
            showStatus("âŒ Transaction rejected by user", "warning");
          } else if (error.message.includes("circuit breaker")) {
            console.error("ğŸ”§ Circuit breaker detected - attempting bypass...");
            showStatus(
              "ğŸ”„ Circuit breaker detected, attempting bypass...",
              "warning"
            );

            // Try to bypass the circuit breaker
            const bypassProvider = await bypassCircuitBreaker();
            if (bypassProvider) {
              console.log("âœ… Bypass successful, retrying transaction...");
              showStatus("âœ… Bypass successful, retrying...", "success");

              // Retry the transaction with the bypass provider
              try {
                // Create new contracts with bypass provider
                const bypassSigner = bypassProvider.getSigner(userAddress);
                const bypassGameToken = new ethers.Contract(
                  CONFIG.contracts.GAME_TOKEN,
                  ABIS.ERC20,
                  bypassSigner
                );

                console.log("ğŸ” Retrying approval with bypass provider...");
                const approveTx = await bypassGameToken.approve(
                  CONFIG.contracts.PLAY_GAME,
                  requiredAmount
                );
                await approveTx.wait();
                console.log("âœ… Approval successful with bypass!");

                showStatus("ğŸ‰ Transaction successful with bypass!", "success");
                await updateBalances();
                await loadAssignedMatches();
                return;
              } catch (bypassError) {
                console.error("âŒ Bypass retry failed:", bypassError);
              }
            }

            showStatus(
              "âŒ MetaMask blocked transaction. Please check network settings.",
              "error"
            );
            console.error(
              "ğŸ”§ Circuit breaker issue - check MetaMask network configuration"
            );

            // Add a help button for network issues
            setTimeout(() => {
              const helpBtn = document.createElement("button");
              helpBtn.className = "btn btn-secondary";
              helpBtn.style.marginTop = "10px";
              helpBtn.innerHTML = "ğŸ”§ Fix Network Settings";

              // Add a bypass button
              const bypassBtn = document.createElement("button");
              bypassBtn.className = "btn btn-primary";
              bypassBtn.style.marginTop = "10px";
              bypassBtn.style.marginLeft = "10px";
              bypassBtn.innerHTML = "ğŸ”„ Try Bypass";
              bypassBtn.onclick = async () => {
                console.log("ğŸ”„ Manual bypass attempt...");
                showStatus("ğŸ”„ Attempting manual bypass...", "warning");

                const bypassProvider = await bypassCircuitBreaker();
                if (bypassProvider) {
                  showStatus(
                    "âœ… Bypass successful! Try staking again.",
                    "success"
                  );
                } else {
                  showStatus(
                    "âŒ Bypass failed. Please reset network settings.",
                    "error"
                  );
                }
              };
              if (statusMessage) {
                statusMessage.appendChild(bypassBtn);
              }
              helpBtn.onclick = () => {
                alert(`To fix the circuit breaker issue:

      1. Open MetaMask
      2. Go to Settings â†’ Networks
      3. Delete "Localhost 8545" network
      4. Add network again with:
         - Network Name: Localhost 8545
         - RPC URL: http://127.0.0.1:8545
         - Chain ID: 1337
         - Currency Symbol: ETH

      5. Go to Settings â†’ Advanced
      6. Click "Clear activity and nonce data"
      7. Refresh this page and try again

      If that doesn't work, try using a different browser or incognito mode.`);
              };
              const statusMessage = document.querySelector(".status-message");
              if (statusMessage) {
                statusMessage.appendChild(helpBtn);
              }
            }, 1000);
          } else if (
            error.message.includes("could not coalesce error") ||
            error.message.includes("missing revert data")
          ) {
            showStatus(
              "âŒ You need GT tokens to stake! Please buy GT tokens with USDT first.",
              "error"
            );
            // Add a quick action button
            setTimeout(() => {
              const buyGtBtn = document.createElement("button");
              buyGtBtn.className = "btn btn-primary";
              buyGtBtn.style.marginTop = "10px";
              buyGtBtn.innerHTML = "ğŸ’° Buy GT Tokens Now";
              buyGtBtn.onclick = () => {
                document.getElementById("usdtAmount").focus();
                document
                  .getElementById("usdtAmount")
                  .scrollIntoView({ behavior: "smooth" });
              };
              document.querySelector(".status-message").appendChild(buyGtBtn);
            }, 1000);
          } else {
            showStatus("âŒ Staking failed: " + error.message, "error");
          }
        }
      }

      // Stake in match button (manual entry)
      stakeInMatchBtn.onclick = async () => {
        try {
          const matchIdValue = manualMatchId.value.trim();
          if (!matchIdValue) {
            showStatus("âš ï¸ Enter match ID", "warning");
            return;
          }

          stakeInMatchBtn.innerHTML =
            '<div class="spinner"></div><span>Staking...</span>';

          // If user enters the full hex match ID, use it directly
          let matchIdBytes32;
          if (matchIdValue.startsWith("0x") && matchIdValue.length === 66) {
            // It's a full bytes32 hex string
            matchIdBytes32 = matchIdValue;
          } else {
            // For now, show an error - user must enter the full match ID
            showStatus("âŒ Please enter the full match ID (0x...)", "error");
            stakeInMatchBtn.innerHTML = "<span>âš¡ Stake in Match</span>";
            return;
          }

          // Get match details to find stake amount
          const match = await contracts.playGame.getMatch(matchIdBytes32);
          const stakeAmountWei = match[3];
          const stakeAmount = ethers.formatEther(stakeAmountWei);

          await stakeInMatch(matchIdBytes32, stakeAmount);

          manualMatchId.value = "";
          stakeInMatchBtn.innerHTML = "<span>âš¡ Stake in Match</span>";
        } catch (error) {
          console.error(error);
          stakeInMatchBtn.innerHTML = "<span>âš¡ Stake in Match</span>";
          showStatus("âŒ Manual staking failed: " + error.message, "error");
        }
      };

      // Load match details for result declaration
      async function loadMatchForResult() {
        const matchIdValue = resultMatchId.value.trim();
        if (!matchIdValue || !contracts.playGame) {
          player1Label.textContent = "Player 1: Enter match ID to load";
          player2Label.textContent = "Player 2: Enter match ID to load";
          player1Winner.disabled = true;
          player2Winner.disabled = true;
          return;
        }

        try {
          // Handle match ID input
          let matchIdBytes32;
          if (matchIdValue.startsWith("0x") && matchIdValue.length === 66) {
            matchIdBytes32 = matchIdValue;
          } else {
            player1Label.textContent = "Player 1: Enter full match ID (0x...)";
            player2Label.textContent = "Player 2: Enter full match ID (0x...)";
            player1Winner.disabled = true;
            player2Winner.disabled = true;
            return;
          }

          const match = await contracts.playGame.getMatch(matchIdBytes32);
          console.log("Match data for result declaration:", match);

          const p1Address = match[1];
          const p2Address = match[2];
          const stakeAmount = ethers.formatEther(match[3]);
          const status = match[4]; // 0=WAITING, 1=STAKED, 2=SETTLED, 3=REFUNDED

          console.log("Match details:", {
            p1Address,
            p2Address,
            stakeAmount,
            status,
          });

          player1Label.textContent = `Player 1: ${p1Address.slice(
            0,
            8
          )}...${p1Address.slice(-6)} (${stakeAmount} GT)`;
          player2Label.textContent = `Player 2: ${p2Address.slice(
            0,
            8
          )}...${p2Address.slice(-6)} (${stakeAmount} GT)`;

          // Always enable radio buttons if we have valid addresses
          player1Winner.disabled = false;
          player2Winner.disabled = false;
          player1Winner.value = p1Address;
          player2Winner.value = p2Address;

          // Show status based on match state
          if (status === 1) {
            // STAKED - ready for result
            showStatus("âœ… Match ready for result declaration", "success");
          } else if (status === 0) {
            showStatus(
              "âš ï¸ Match not ready - players still need to stake",
              "warning"
            );
          } else if (status === 2) {
            showStatus("â„¹ï¸ Match already settled", "warning");
          } else if (status === 3) {
            showStatus("â„¹ï¸ Match was refunded", "warning");
          }
        } catch (error) {
          console.error("Error loading match:", error);
          player1Label.textContent = "Player 1: Error loading match";
          player2Label.textContent = "Player 2: Error loading match";
          player1Winner.disabled = true;
          player2Winner.disabled = true;
          showStatus("âŒ Error loading match: " + error.message, "error");
        }
      }

      // Load match details for result declaration
      resultMatchId.oninput = loadMatchForResult;

      // Add refresh button functionality
      const refreshMatchBtn = document.getElementById("refreshMatchBtn");
      if (refreshMatchBtn) {
        refreshMatchBtn.onclick = loadMatchForResult;
      }

      // Declare match result
      declareResultBtn.onclick = async () => {
        try {
          const matchIdValue = resultMatchId.value.trim();
          const selectedWinner = document.querySelector(
            'input[name="winner"]:checked'
          );

          if (!matchIdValue) {
            showStatus("âš ï¸ Enter match ID", "warning");
            return;
          }

          if (!selectedWinner) {
            showStatus("âš ï¸ Select a winner", "warning");
            return;
          }

          const winnerAddress = selectedWinner.value;

          showStatus("â³ Declaring match result...", "warning");
          declareResultBtn.innerHTML =
            '<div class="spinner"></div><span>Declaring...</span>';

          const response = await fetch(`${CONFIG.apiBaseUrl}/match/result`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              matchId: matchIdValue,
              winner: winnerAddress,
            }),
          });

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.error || "Result declaration failed");
          }

          // Clear form
          resultMatchId.value = "";
          player1Winner.checked = false;
          player2Winner.checked = false;
          player1Label.textContent = "Player 1: Enter match ID to load";
          player2Label.textContent = "Player 2: Enter match ID to load";
          declareResultBtn.innerHTML = "<span>ğŸ† Announce Winner</span>";

          // Update balances immediately after result declaration
          await updateBalances();

          showStatus("ğŸ‰ Match result declared successfully!", "success");
          addEvent(
            `ğŸ† Match result: ${winnerAddress.slice(
              0,
              8
            )}...${winnerAddress.slice(-6)} won!`
          );
        } catch (error) {
          console.error(error);
          declareResultBtn.innerHTML = "<span>ğŸ† Announce Winner</span>";
          showStatus("âŒ Result declaration failed: " + error.message, "error");
        }
      };

      // Show status
      function showStatus(message, type) {
        statusContainer.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
        setTimeout(() => {
          statusContainer.innerHTML = "";
        }, 5000);
      }

      // Add event
      function addEvent(eventText) {
        const eventItem = document.createElement("div");
        eventItem.className = "event-item";
        eventItem.innerHTML = `
                       <div class="event-time">${new Date().toLocaleTimeString()}</div>
                       <div class="event-content">${eventText}</div>
                     `;

        if (eventsList.firstChild?.textContent?.includes("Waiting")) {
          eventsList.innerHTML = "";
        }

        eventsList.insertBefore(eventItem, eventsList.firstChild);

        // Keep last 15 events
        while (eventsList.children.length > 15) {
          eventsList.removeChild(eventsList.lastChild);
        }
      }

      // Load leaderboard
      async function loadLeaderboard() {
        try {
          const leaderboardList = document.getElementById("leaderboardList");
          leaderboardList.innerHTML = `
             <div class="event-item">
               <div class="event-time">Loading...</div>
               <div class="event-content">Fetching leaderboard data</div>
             </div>
           `;

          const response = await fetch("http://localhost:3001/leaderboard");
          const data = await response.json();
          const leaderboard = data.leaderboard || [];

          if (leaderboard.length === 0) {
            leaderboardList.innerHTML = `
               <div class="event-item">
                 <div class="event-time">No data</div>
                 <div class="event-content">No leaderboard data available yet</div>
               </div>
             `;
            return;
          }

          leaderboardList.innerHTML = "";

          leaderboard.forEach((entry, index) => {
            const rank = index + 1;
            const rankIcon =
              rank === 1
                ? "ğŸ¥‡"
                : rank === 2
                ? "ğŸ¥ˆ"
                : rank === 3
                ? "ğŸ¥‰"
                : `#${rank}`;

            const leaderboardItem = document.createElement("div");
            leaderboardItem.className = "event-item";
            leaderboardItem.innerHTML = `
                <div class="event-time">${rankIcon} ${entry.address.slice(
              0,
              6
            )}...${entry.address.slice(-4)}</div>
                <div class="event-content">
                  <div style="margin-bottom: 0.5rem;">
                    <strong>Wins:</strong> ${
                      entry.wins
                    } â€¢ <strong>Total GT Won:</strong> ${entry.gtWon} GT
                  </div>
                  <div style="font-size: 0.8rem; color: var(--text-muted);">
                    <strong>Matches Played:</strong> ${
                      entry.totalMatches
                    } â€¢ <strong>Win Rate:</strong> ${entry.winRate}%
                  </div>
                </div>
              `;

            leaderboardList.appendChild(leaderboardItem);
          });
        } catch (error) {
          console.error("Error loading leaderboard:", error);
          const leaderboardList = document.getElementById("leaderboardList");

          if (error.message.includes("fetch")) {
            leaderboardList.innerHTML = `
               <div class="event-item">
                 <div class="event-time">Service Unavailable</div>
                 <div class="event-content">
                   Leaderboard service not running. Please start the leaderboard service:<br>
                   <code>node tools/leaderboard.js</code>
                 </div>
               </div>
             `;
          } else {
            leaderboardList.innerHTML = `
               <div class="event-item">
                 <div class="event-time">Error</div>
                 <div class="event-content">Failed to load leaderboard: ${error.message}</div>
               </div>
             `;
          }
        }
      }

      // Auto-refresh leaderboard periodically
      let leaderboardRefreshInterval;
      function startLeaderboardAutoRefresh() {
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
        }
        // Refresh leaderboard every 10 seconds when connected
        leaderboardRefreshInterval = setInterval(async () => {
          if (isConnected && userAddress) {
            await loadLeaderboard();
          }
        }, 10000);
      }

      function stopLeaderboardAutoRefresh() {
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
          leaderboardRefreshInterval = null;
        }
      }

      // Initialize
      window.addEventListener("load", init);
    </script>
  </body>
</html>
